@startuml
skinparam style strictuml
skinparam classAttributeIconSize 0
hide enum methods
hide empty members

interface model.HintDisplayMode {
    + convertHintLine(hintLine : HintLine) : Color[]
}

class model.ClassicMode implements model.HintDisplayMode {
    + convertHintLine(hintLine : HintLine) : Color[]
}

class model.EasyMode implements model.HintDisplayMode {
    + convertHintLine(hintLine : HintLine) : Color[]
}

enum model.Mode {
    + EASY
    + CLASSIC
    + NUMERIC
}

class view.GameWindow implements model.RoundObserver{

}

class view.StartWindow {
}

class view.EndWindow {
}

interface model.RoundObserver {
    + reactToAttempt(combination : Combination, hintLine : HintLine)
    + reactToRoundEnd(roundWon : Boolean, score : Integer)
    + reactToModeChanged(mode : Mode)
}

enum model.Pawn {
    + RED
    + GREEN
    + YELLOW
    + BLUE
    + BLACK
    + ORANGE
    + PURPLE
    + PINK
}

class model.Round {
    + Round(settings : Settings)
    + checkAttempt(combination : Combination) : Boolean
    + computeScore() : Integer
    + addObserver(observer : RoundObserver)
    - notifyAttempt()
    - notifyRoundEnd(roundWon : Boolean, score : Integer)
    - notifyModeChanged()
}

class model.Settings {
    + Settings(attemptNumber : Integer, combinationLength : Integer, pawnNumber : Integer, mode : Mode)
    - attemptNumber : Integer
    - combinationLength : Integer
    - pawnNumber : Integer
    + getAttemptNumber() : Integer
    + getCombinationLength() : Integer
    + getPawnNumber() : Integer
    + getMode() : Mode
}

class model.SecretCombination extends model.Combination{
    + <<create>> SecretCombination(combinationLength : Integer, pawnNumber : Integer))
}

class model.Combination {
    + Combination(pawns : Pawn[])
    + setPawns(pawns : Pawn[])
    + getPawn(index : Integer) : Pawn
    + getCombinationLength() : Integer
    + containsPawn(pawn : Pawn) : Boolean
}

class model.HintLine {
    + HintLine(combination : Combination, secretCombination : SecretCombination)
    + getHint(index : Integer) : Hint
    + perfectMatch() : Boolean
    + hintLineLength() : Integer
}

class model.Game {
    - playerName : String
    - score : Integer
    + <<create>> Game()
    + setMode(mode : Mode)
    + configureGame(settings : Settings, roundNumber : Integer)
    + nextRound() : Round
    + getFinalScore() : Integer
    + addObserver(observer : GameObserver)
    - notifyGameEnd()
}

enum model.Hint {
    + RIGHT_PLACE
    + WRONG_PLACE
    + ABSENT
}

class controler.MastermindApp {
    + {static} main(args : String[])
}

class view.Announcer implements model.RoundObserver{
    + reactToAttempt(combination : Combination, hintLine : HintLine)
    + reactToRoundEnd(roundWon : Boolean, score : Integer)
}

class model.GameObserver {
    + reactToGameEnd(score : Integer)
}

controler.MastermindApp ..> "<<uses>>" model.Settings
model.Game o--> "1\n-settings" model.Settings : Configure <
model.Settings o--> "1\n-mode" model.Mode : influence <
model.Round o--> "1\n-settings" model.Settings : Configure <
model.Round *--> "1\n-secretCombination" model.SecretCombination : conserve >
model.Round o--> "1 .. 12\n-attempts" model.Combination : garde >
model.Round o--> "1 .. 12\n-hintLine" model.HintLine : > garde
model.Round ..> "<<uses>>" model.Hint
model.HintLine o-> "2 .. 6\n-hints" model.Hint : contient >
model.Game *--> "1 .. 5\n-rounds" model.Round : contient >
model.Game o--> "*\n-observers" model.GameObserver
model.Combination o-> "2 .. 6\n-pawns" model.Pawn : compose <
controler.MastermindApp *--> "1\n-game" model.Game : joue >
controler.MastermindApp ..> "<<uses>>" view.EndWindow
controler.MastermindApp ..> "<<uses>>" view.GameWindow
controler.MastermindApp ..> "<<uses>>" view.StartWindow
model.Round o--> "*\n-observers" model.RoundObserver
view.GameWindow o--> "1\n-displayer" model.HintDisplayMode : utilise >
view.Announcer o--> "1\n-displayer" model.HintDisplayMode : utilise >


@enduml